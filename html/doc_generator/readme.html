<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>moreserverless.com - Doc Generator README</title>
    <link rel="stylesheet" href="../../css/style.css">
</head>
<body>
    <header>
        <div class="logo-title">
            <img src="../../img/moreserverless_avatar.jpg" alt="moreserverless.com avatar" class="header-icon">
            <h1>moreserverless.com</h1>
        </div>
        <nav>
            <a href="../../index.html">Index</a>
        </nav>
    </header>

    <main>
        <h3>Human In The Loop Note:</h3><p>This is the README that was generated by Gemini AI using
        the ADO pipeline to read the repository</p>

        <h1>Doc Generator</h1>

        <h2>Overview</h2>
        <p>The Doc Generator is a Python Flask service designed to automate the creation of team documentation. It leverages the power of the Google Gemini AI API to generate comprehensive and contextually relevant documentation based on various inputs, which are processed via API calls. This service is intended to be deployed on Google Cloud Run, providing a scalable and efficient solution for documentation needs.</p>

        <h2>Quick Start</h2>
        <p>To get the Doc Generator running locally for development or testing, follow these steps:</p>

        <h3>1. <strong>Clone the Repository:</strong></h3>
        <pre><code class="language-bash">git clone https://github.com/your-org/doc-generator.git
cd doc-generator</code></pre>

        <h3>2. <strong>Set up a Virtual Environment:</strong></h3>
        <pre><code class="language-bash">python3 -m venv .venv
source .venv/bin/activate</code></pre>

        <h3>3. <strong>Install Dependencies:</strong></h3>
        <p>(Assumes <code>requirements.txt</code> exists with necessary packages)</p>
        <pre><code class="language-bash">pip install flask google-generativeai python-dotenv</code></pre>
        <p>*If a <code>requirements.txt</code> file is provided, use:*</p>
        <pre><code class="language-bash">pip install -r requirements.txt</code></pre>

        <h3>4. <strong>Obtain a Google Gemini API Key:</strong></h3>
        <p>If you don't have one, get your API key from <a href="https://aistudio.google.com/apikey">Google AI Studio</a>.</p>

        <h3>5. <strong>Configure Environment Variables:</strong></h3>
        <p>Create a <code>.env</code> file in the root of the project and add your Gemini API key:</p>
        <pre><code class="language-bash">GEMINI_API_KEY="YOUR_GEMINI_API_KEY_HERE"</code></pre>
        <p>*(Note: The <code>app.py</code> snippet indicates it looks for <code>GEMINI_API_KEY</code> directly from <code>os.environ</code>. While <code>python-dotenv</code> is imported, its usage for <code>GEMINI_API_KEY</code> in the snippet is commented out, suggesting direct environment variable injection is preferred for deployment, but <code>.env</code> is convenient for local development.)*</p>

        <h3>6. <strong>Run the Application:</strong></h3>
        <pre><code class="language-bash">export FLASK_APP=app.py
flask run</code></pre>
        <p>The service will typically start on <code>http://127.0.0.1:5000</code>.</p>

        <h2>Architecture</h2>
        <p>The Doc Generator is built as a Flask microservice and designed for cloud-native environments, specifically Google Cloud Run.</p>

        <ul>
            <li><strong>Flask Application (<code>app.py</code>):</strong> The core web service that handles incoming API requests, orchestrates the documentation generation process, and returns the results.</li>
            <li><strong>Google Gemini API Client (<code>google.genai</code>):</strong> Integrated for its powerful AI capabilities. It serves as the intelligent backend responsible for interpreting input and generating human-like documentation.</li>
            <li><strong>Environment Variables (<code>python-dotenv</code>):</strong> Used to manage sensitive configuration parameters like API keys, ensuring they are not hardcoded and can be easily managed across different environments.</li>
            <li><strong>Local File System Operations (<code>tempfile</code>, <code>shutil</code>, <code>pathlib</code>):</strong> The presence of these imports suggests the service may perform temporary file operations. This could involve storing intermediate files, processing input code snippets, or managing generated content before returning it via the API.</li>
            <li><strong>Subprocess Management (<code>subprocess</code>):</strong> The <code>subprocess</code> module implies the service might execute external commands, potentially for code analysis tools, linters, or other utilities that complement the documentation generation process.</li>
            <li><strong>Cloud Run (Deployment Target):</strong> The service is explicitly designed for deployment on Google Cloud Run, indicating it's stateless, containerized, and scales automatically based on request load.</li>
        </ul>

        <h2>API Endpoints</h2>
        <p>(Based on the service's purpose, common endpoints are assumed as the provided snippet does not include route definitions.)</p>

        <h3><code>POST /generate</code></h3>
        <p>Generates documentation based on provided input.</p>

        <ul>
            <li><strong>Description:</strong> This is the primary endpoint for triggering documentation generation. It accepts a payload, likely containing code, specifications, or other textual content, and returns generated documentation.</li>
            <li><strong>Request Body (Example):</strong></li>
        </ul>
        <pre><code class="language-json">{
"type": "code_snippet",
"language": "python",
"content": "def factorial(n):
 if n == 0: return 1
 else: return n * factorial(n-1)",
"context": "This is a recursive factorial function. Generate docstrings and a high-level explanation."
}</code></pre>
        <ul>
            <li><strong>Response Body (Example):</strong></li>
        </ul>
        <pre><code class="language-json">{
"status": "success",
"documentation": "### Factorial Function

**Description:** This Python function calculates the factorial of a non-negative integer using recursion.

**Parameters:**
- `n` (int): The non-negative integer for which to calculate the factorial.

**Returns:**
- `int`: The factorial of `n`.

**Example:**
```python
print(factorial(5)) # Output: 120
```",
"generated_by": "Gemini AI"
}</code></pre>

        <h3><code>GET /health</code></h3>
        <p>Performs a health check on the service.</p>

        <ul>
            <li><strong>Description:</strong> A standard endpoint to check if the service is running and responsive.</li>
            <li><strong>Response Body (Example):</strong></li>
        </ul>
        <pre><code class="language-json">{
"status": "healthy",
"message": "Doc Generator service is operational"
}</code></pre>

        <h2>Configuration</h2>
        <p>The following environment variables are essential for the Doc Generator to function correctly:</p>

        <ul>
            <li><strong><code>GEMINI_API_KEY</code> (Required):</strong>
                <ul>
                    <li><strong>Description:</strong> Your API key for accessing the Google Gemini Generative AI service.</li>
                    <li><strong>Source:</strong> Obtainable from <a href="https://aistudio.google.com/apikey">Google AI Studio</a>.</li>
                    <li><strong>Usage:</strong> Must be set in the environment where the application runs (e.g., in a <code>.env</code> file locally, or directly in Cloud Run environment variables).</li>
                    <li><strong>Example:</strong> <code>GEMINI_API_KEY="AIzaSy..."</code></li>
                </ul>
            </li>
            <li><strong><code>FLASK_APP</code> (Standard Flask Variable):</strong>
                <ul>
                    <li><strong>Description:</strong> Specifies the main Flask application file.</li>
                    <li><strong>Usage:</strong> Set to <code>app.py</code> when running with <code>flask run</code>.</li>
                    <li><strong>Example:</strong> <code>export FLASK_APP=app.py</code></li>
                </ul>
            </li>
            <li><strong><code>FLASK_ENV</code> (Optional, but Recommended):</strong>
                <ul>
                    <li><strong>Description:</strong> Sets the Flask environment. Can be <code>development</code> or <code>production</code>.</li>
                    <li><strong>Usage:</strong> Influences debugging, error handling, and other Flask behaviors. Set to <code>production</code> for deployments.</li>
                    <li><strong>Example:</strong> <code>export FLASK_ENV=development</code></li>
                </ul>
            </li>
        </ul>

        <h2>Dependencies</h2>
        <p>The Doc Generator relies on the following external services:</p>

        <ul>
            <li><strong>Google Gemini API:</strong> This is the primary external dependency, providing the generative AI capabilities for creating documentation. An active API key is required for the service to function.</li>
        </ul>

        <h2>Common Tasks</h2>

        <h3>How to add a new feature</h3>
        <ol>
            <li><strong>Understand the Requirement:</strong> Clearly define what the new feature should accomplish.</li>
            <li><strong>Create a New Branch:</strong> From <code>main</code>, create a feature branch: <code>git checkout -b feature/my-new-feature</code>.</li>
            <li><strong>Implement Logic:</strong> Add or modify code in <code>app.py</code> (or new modules) to implement the feature. This might involve:
                <ul>
                    <li>Adding new Flask routes (<code>@app.route</code>).</li>
                    <li>Creating new functions to process input or interact with Gemini differently.</li>
                    <li>Refactoring existing logic for improved modularity.</li>
                </ul>
            </li>
            <li><strong>Write Tests:</strong> Add unit and/or integration tests for your new feature to ensure it works as expected and doesn't introduce regressions.</li>
            <li><strong>Update Documentation:</strong> If the new feature affects API endpoints, configuration, or usage, update this <code>README.md</code> or any other relevant documentation.</li>
            <li><strong>Test Locally:</strong> Run the application locally and thoroughly test your new feature.</li>
            <li><strong>Submit Pull Request:</strong> Push your branch and open a pull request to the <code>main</code> branch for review.</li>
        </ol>

        <h3>How to run tests</h3>
        <p>(Assuming a testing framework like <code>pytest</code> is used.)</p>

        <ol>
            <li><strong>Activate Virtual Environment:</strong>
                <pre><code class="language-bash">source .venv/bin/activate</code></pre>
            </li>
            <li><strong>Install Test Dependencies (if any):</strong>
                <pre><code class="language-bash">pip install pytest # Or from a test-requirements.txt</code></pre>
            </li>
            <li><strong>Run Tests:</strong>
                <pre><code class="language-bash">pytest</code></pre>
            </li>
        </ol>
        <p>If tests are in a specific directory or file:</p>
        <pre><code class="language-bash">pytest tests/
pytest tests/test_app.py</code></pre>

        <h3>How to deploy</h3>
        <p>The Doc Generator is designed for deployment on Google Cloud Run.</p>

        <ol>
            <li><strong>Ensure Docker is Installed:</strong> Make sure Docker Desktop is running or Docker Engine is installed on your system.</li>
            <li><strong>Authenticate Docker (if needed):</strong>
                <pre><code class="language-bash">gcloud auth configure-docker</code></pre>
            </li>
            <li><strong>Build Docker Image:</strong> Create a <code>Dockerfile</code> (not provided in the snippet, but necessary for Cloud Run) and then build your image:
                <pre><code class="language-bash">docker build -t gcr.io/[YOUR_PROJECT_ID]/doc-generator:latest .</code></pre>
                <p>Replace <code>[YOUR_PROJECT_ID]</code> with your Google Cloud Project ID.</p>
            </li>
            <li><strong>Push Docker Image to Google Container Registry (GCR) or Artifact Registry:</strong>
                <pre><code class="language-bash">docker push gcr.io/[YOUR_PROJECT_ID]/doc-generator:latest</code></pre>
            </li>
            <li><strong>Deploy to Google Cloud Run:</strong>
                <pre><code class="language-bash">gcloud run deploy doc-generator \
--image gcr.io/[YOUR_PROJECT_ID]/doc-generator:latest \
--platform managed \
--region [YOUR_REGION] \
--allow-unauthenticated \
--set-env-vars GEMINI_API_KEY="YOUR_GEMINI_API_KEY_HERE"</code></pre>
                <ul>
                    <li>Replace <code>[YOUR_PROJECT_ID]</code> and <code>[YOUR_REGION]</code> (e.g., <code>us-central1</code>).</li>
                    <li>Adjust <code>--allow-unauthenticated</code> as per your security requirements.</li>
                    <li><strong>Crucially, set <code>GEMINI_API_KEY</code> as an environment variable in Cloud Run.</strong> Do <em>not</em> hardcode it in your Docker image. For sensitive keys, consider using Google Secret Manager integrated with Cloud Run.</li>
                </ul>
            </li>
        </ol>
    </main>
</body>
</html>
